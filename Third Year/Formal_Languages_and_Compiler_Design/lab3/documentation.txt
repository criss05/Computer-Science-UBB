Documentation: Lexical Analysis for Custom DSL
==============================================

1. Overview
-----------

This document describes the lexical analysis phase for the domain-specific
programming language (DSL) designed in Lab 1. The implementation uses Flex
for lexical scanning and C for managing the Program Internal Form (PIF)
and Symbol Table (ST).

The lexical analyzer performs the following tasks:

- Reads a source program written in the DSL.
- Identifies tokens such as keywords, operators, identifiers, numbers,
  and string literals.
- Populates a Symbol Table (ST) for identifiers, constants, and strings.
- Populates a Program Internal Form (PIF) to represent the program as a
  sequence of tokens.

2. Tools Used
-------------

2.1 Flex
- It reads a .lxi file with token definitions and generates a C source
  file (lex.yy.c) that scans input text for tokens.
- Regular expressions in Flex are used to define token patterns.

2.2 C Programming Language
- Used to implement:
  - The Symbol Table (BST structure)
  - The Program Internal Form

2.3 GCC (GNU Compiler Collection)
- GCC is used to compile the C code generated by Flex along with custom
  modules (pif.c and st.c) that implement the Program Internal Form and
  Symbol Table.
- Compilation command:
  gcc lex.yy.c pif.c st.c

3. Lexical Tokens Detection
---------------------------

The DSL recognizes the following token types:

3.1 Keywords

Reserved words defined in the BNF:
INPUT, OUTPUT, IF, THEN, ELSE, END, DEF, BEGIN, RETURN

- These are directly added to the PIF with an index of -1.

3.2 Operators

Arithmetic and DSL-specific operators:
+ - * / % ! A C P =
== != >= <= > <

- A → arrangements
- C → combinations
- P → permutations

All operators are added to the PIF with index -1.

3.3 Separators

( ) , 

- Used to separate parameters and function calls.
- Added to PIF with index -1.

3.4 Identifiers

- Regex: [A-Za-z][A-Za-z0-9_]*
- Stored in the Symbol Table with a unique index.
- Added to PIF as identifier with the ST index.

3.5 Constants

- Numbers: [+-]?([1-9][0-9]*|0)(\.[0-9]+)?
- Strings: "..." (enclosed in double quotes)
- Both stored in Symbol Table with unique index.
- Added to PIF as number or string with the ST index.

4. Data Structures
------------------

4.1 Symbol Table (ST)

Implemented as a Binary Search Tree (BST):

typedef struct STNode {
    char* token;
    int index;
    struct STNode* left;
    struct STNode* right;
} STNode;

Operations:

- Insert Node: Adds a new identifier/constant if not present.
- Search Node: Checks if a token already exists in the ST.
- Print ST: Prints all tokens in alphabetical order (in-order traversal).
- Free ST: Recursively frees memory for all nodes.

4.2 Program Internal Form (PIF)

typedef struct {
    char* token;
    int index;
} PIFElement;

typedef struct {
    PIFElement* elements;
    int size;
    int capacity;
} PIF;

Operations:

- init_pif: Initializes PIF with default capacity.
- add_token: Adds a token with its ST index or -1 for keywords/operators.
- print_pif: Prints all tokens in sequential order.
- free_pif: Frees memory used by PIF elements.